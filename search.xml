<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Git Introduction]]></title>
    <url>%2F2018%2F01%2F18%2FGit-Introduction%2F</url>
    <content type="text"><![CDATA[Git 入门Repository 是记录档案或目录状态的地方，储存内容的修改历史记录。在 Repository 的管理下除了储存修改历史记录之外，还可以追踪内容的状态和版本。 首先，Git 的数据库分为远端数据库和本地端数据库。 远端数据库：配有专用的伺服器，为了让多人共享而建立的数据库。 本地端数据库：为了方便用户个人使用，在自己的机器上配置的数据库。 可以在本地端数据库上使用像是还原更改、跟踪更改等所有 Git 版本控制功能。不过，如果想要公开在本地端数据库的修改内容，就需要将内容上传到远端数据库了。另外，透过远端数据库还可以取得其他人修改的内容。 建立数据库建立本地数据库的方法有两种：一种是重建新数据库，另一种是复制远端数据库。 记录修改的提交把变更与新增的档案/目录储存到数据库中，需要执行 Commit，执行提交后，数据库会产生上次提交的状态与现在状态的差异记录，也被称为 Revision 工作目录（ Working Tree）是保存您目前正在处理档桉的目录，Git 相关的操作都会在这个目录下完成。 索引 ( Index )位于工作目录和数据库之间，是为了向数据库提交作准备的暂存区域。 工作目录与索引所以在工作目录上做的任何变更并不会直接提交到数据库的。Git 在执行提交的时候，不是直接将工作目录的状态储存到数据库，而是将索引的状态储存到数据库。因此，要提交变更，首先必需要把变更内容加入到索引中。 索引的存在可以排除工作目录里不必要的档案提交，还可以只将档案变更内容的一部分加入索引并提交。 Push (推送) 为了将本地端数据库的修改历史共享到远程数据库，必须上​​传本地端数据库中储存的修改历史。 为此，需要在 Git 执行 Push (推送) 操作。执行 Push 之后，本地端的修改历史会被上传到远端数据库。远端数据库的修改历史就会和本地端数据库的修改历史保持同步。 若是共享的远端数据库由多人同时作业，那么作业完毕后所有人都会把修改历史 push 到远端数据库。所以需要同步其他人 push 的修改内容到自己的本地端数据库。 Pull (拉取)欲同步远端数据库以更新本地端数据库，请使用 Pull(拉取)。 执行 pull 之后，会从远端数据库下载最新的修改历史，将其同步到自己的本地端数据库。 origin/master：代表远端数据库「origin」的「master」分支位置。 origin/HEAD：代表远端数据库「origin」当前提交的位置。通常和「origin/master」的位置相同。 master：代表本地端数据库的「master」分支位置。 上次的 push 到执行下一次的 push 的期间，如果有其他人 push 更新了远端数据库，而你没有更新本地端数据库，那么你的 push 会被拒绝。 为了能支援同时进行数个功能的增加或版本控制，Git 具备了分支的功能。分支是为了将修改记录的整体流程分开储存，让分开的分支不受其他分支的影响，所以在同一个数据库裡可以同时进行多个不同的修改。 为了让群组的成员不受其他成员的影响，可以在主要分支建立自己专用的分支。完成作业的成员们，将自己分支的修改导入到主要分支，这样大家都可以不受其他成员的影响，导入自己的修改内容。而且每个提交的历史记录都会被储存，当发生问题时，可以更容易找到发生问题的地方。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Git</tag>
        <tag>版本控制</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Simple Shopping Cart using Sessions]]></title>
    <url>%2F2018%2F01%2F05%2FSimple-Shopping-Cart-using-Sessions%2F</url>
    <content type="text"><![CDATA[会话用于维持请求和请求之间的状态。HTTP 请求自身是完全无状态的。从服务器的角度来说，当月户的 Web 浏览器打开第一个连接到服务器的套接字时请求就开始了，直到服务器返回最后一个数据包并关闭连接时，该请求将结束。此时，在用户的浏览器和服务器之间不再有任何联系，当下个连接开始时，无法将新的请求与之前的请求关联起来。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP の教科書 Part I]]></title>
    <url>%2F2017%2F12%2F17%2FHTTP-Textbook-Part1%2F</url>
    <content type="text"><![CDATA[1. Web 及网络基础1.1 网络基础 TCP/IP通常使用的网络是在 TCP/IP 协议族（IEEE802, FDDI, TCP, FTP, PPPoE, UDP..）的基础上运作的，而 HTTP 属于它内部的一个子集。 TCP/IP 协议族按层次分别分为：应用层，传输层，网络层和数据链路层。 1.2 TCP/IP 通信传输流客户端请求：发送端在层与层之间传输数据时，每经过一层时必定会被打上一个该层所属的 Header 信息。 服务器端响应：接收端在层层传输数据时，每经过一层都会把对应的 Header 信息消去。这种把数据信息包装起来的做法成为封装。 1.3 与 HTTP 关系密切的协议：IP、TCP 和 DNSIP 协议：作用是把各种数据包传送给对方，要保证确实传送到对方那里，两个重要的条件是 IP 地址和 MAC 地址。 IP 地址指明了节点被分配到的地址，MAC 地址是指网卡所属的固定地址。IP 地址和 MAC 地址进行配对，前者可变换，后者基本上不会更改 TCP 协议：TCP 协议位于传输层，提供可靠的字节流服务。 字节流服务是指为了方便传输，将大块数据分割成以报文段（segment）为单位的数据包进行管理。 三次握手协议：发送端首先发送一个带 SYN 标志的数据包给对方。接收端收到后，回传一个带有 SYN/ACK 标志的数据包以示传达确认信息。最后，发送端再回传一个带 ACK 标志的数据包，代表“握手”结束。 若在握手过程中某个阶段莫名中断，TCP 协议会再次以相同的顺序发送相同的数据包。 DNS 域名解析 1.4 URI &amp; URL统一资源标识符 与 统一资源定位符 URI：采用 HTTP 协议时，协议方案就是 http，除此之外，还有 ftp、mailto、telnet、file等。URL 是 URI 的子集。 绝对 URI 格式：协议方案名、登录信息、服务器地址、服务器端口号、带层次的文件路径、查询字符串、片段标识符 2. 简单的 HTTP 协议 2.1 告知服务器意图的 HTTP 方法 GET：获取资源GET 方法用来请求访问已被 URI 识别的资源。指定的资源经过服务器端解析后返回相应内容。也就是说，如果请求的资源师文本，那就保持原样返回；如果像是 CGI 那样的程序，则返回经过执行后的输出结果。 POST：传输实体主体虽然用 GET 方法也可以传输实体的主体，但一般不用 GET 方法进行传输，而是用 POST 方法。虽说 POST 的功能与 GET 很相似，但 POST 的主要目的并不是获取相应的主题内容。 PUT：传输文件PUT 方法用来传输文件。就像 FTP 协议的文件上传一样，要求在请求报文的主体中包含文件内容，然后保存到请求 URI 指定的位置。 HTTP/1.1 的 PUT 方法自身不带验证机制，任何人都可以上传文件，存在安全性问题，因此一般的 Web 网站不使用该方法。 HEAD：获得报文 Header和 GET 方法一样，只是不返回报文主体部分，用于确认 URI 的有效性及资源更新的日期时间等。 DELETE：用来删除文件，与 PUT 相反。 OPTIONS：询问支持的方法用来查询针对请求 URI 指定的资源支持的方法。 TRACE：追踪路径让 Web 服务器端将之前的请求通信环回给客户端的方法。 CONNECT：要求用隧道协议连接代理要求在与代理服务器通信时建立隧道，实现用隧道协议进行 TCP 通信。主要使用 SSL 和 TLS 协议把通信的内容加密后经网络隧道传输。 2.2 使用 Cookie 的状态管理HTTP 是无状态协议，它不对之前发生过的请求和响应的状态进行管理。也就是说，无法根据之前的状态进行本次的请求处理。 假设要求登录认证的 Web 页面本身无法进行状态的管理（不记录已登录的状态），那么每次跳转新页面不是要再次登录，就是要在每次请求报文中附加参数来管理登录状态。 保留无状态协议这个特征的同时又要解决类似的矛盾问题，于是引入了 Cookie 技术。Cookie 技术通过在请求和响应报文中写人 Cookie 信息来控制客户端的状态。 Cookie 会根据从服务器端发送的响应报文内的一个叫做 Set-Cookie 的首部字段信息，通知客户端保存 Cookie。当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入 Cookie 值后发送出去。服务器端发现客户端发送过来的 Cookie 后，会去检查究竟是从哪个客户端发来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。 3. HTTP 报文内的 HTTP 信息HTTP 报文大致可以分为报文首部和报文主体。通常，并不一定要有报文主体。 报文首部：请求行、状态行、首部字段 4. 返回结果的 HTTP 状态码状态码的职责是当客户端向服务器端发送请求时，描述返回的请求结果。借助状态码，用户可以知道服务器端是正常处理了请求，还是出现了错误。 204该状态码代表服务器接收的请求已成功处理，但在返回的响应报文中不含实体的主体部分。另外，也不允许返回任何实体的主体。比如，当从浏览器发出请求处理后，返回 204 响应，那么浏览器显示的页面不发生更新。 一般在只需要从客户端往服务器发送信息，而对客户端不需要发送新信息内容的情况下使用。 301永久性重定向。该状态码表示请求的资源已被分配了新的 URI，以后应使用资源现在所指的 URI。也就是说，如果已经把资源对应的 URI 保存为书签了，这时应该按 Location 首部字段提示的 URI 重新保存。 像下方给出的请求 URI，当指定资源路径的最后忘记添加斜杠“/”，就会产生 301 状态码。 302和 301 Moved Permanently 状态码相似，但 302 状态码代表的资源不是被永久移动，只是临时性质的。换句话说，已移动的资源对应的 URI 将来还有可能发生改变。比如，用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。 304该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。 401该状态码表示发送的请求需要有通过 HTTP 认证（BASIC 认证、DIGEST 认证）的认证信息。另外若之前已进行过 1 次请求，则表示用户认证失败。 返回含有 401 的响应必须包含一个适用于被请求资源的 WWW- Authenticate 首部用以质询（challenge）用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。 403该状态码表明对请求资源的访问被服务器拒绝了。服务器端没有必要给出拒绝的详细理由，但如果想作说明的话，可以在实体的主体部分对原因进行描述，这样就能让用户看到了。 未获得文件系统的访问授权，访问权限出现某些问题（从未授权的发送源 IP 地址试图访问）等列举的情况都可能是发生 403 的原因。 500该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。 503该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写人 Retry - After 首部字段再返回给客户端。 5. 与 HTTP 协作的 Web 服务器缓存代理代理转发响应时，缓存代理（Caching Proxy）会预先将资源的副本（缓存）保存在代理服务器上。 当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回。 透明代理转发请求或响应时，不对报文做任何加工的代理类型被称为透明代理（Transparent Proxy）。反之，对报文内容进行加工的代理被称为非透明代理。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>HTTP</tag>
        <tag>JavaWeb</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 函数 DOM BOM]]></title>
    <url>%2F2017%2F12%2F14%2FJavaScript-Function-DOM-BOM%2F</url>
    <content type="text"><![CDATA[1. JavaScript 函数JavaScript 使用关键字 function 定义函数。函数可以通过声明定义，也可以是一个表达式。 123functionName(parameter1, parameter2, parameter3) &#123; // 要执行的代码……&#125; 函数的定义与实用：1234567// 通过表达式定义并使用var x = function (a, b) &#123;return a * b&#125;;var z = x(4, 3);// 通过函数构造器定义var myFunction = function (a, b) &#123;return a * b&#125;var x = myFunction(4, 3); 1234567function myFunction(a, b) &#123; return a * b;&#125;// 作为一个值使用var x = myFunction(4, 3);// 作为表达式使用var x = myFunction(4, 3) * 2; JavaScript 函数有个内置的对象 arguments 对象。argument 对象包含了函数调用的参数数组。 JavaScript 函数调用的四种方式：1234567891011121314151617181920212223242526// 作为一个函数调用function myFunction(a, b) &#123; return a * b;&#125;myFunction(10, 2); // 作为对象的方法调用var myObject = &#123; firstName:"John", lastName: "Doe", fullName: function () &#123; return this.firstName + " " + this.lastName; &#125;&#125;myObject.fullName(); // 使用构造函数调用function myFunction(arg1, arg2) &#123; this.firstName = arg1; this.lastName = arg2;&#125;var x = new myFunction("John","Doe");x.firstName; // 作为函数的方法调用函数，call() 和 apply() 是预定义的函数方法。 两个方法可用于调用函数，两个方法的第一个参数必须是对象本身function myFunction(a, b) &#123; return a * b;&#125;myObject = myFunction.call(myObject, 10, 2); 2. JavaScript HTML DOM当网页被加载时，浏览器会创建页面的文档对象模型（Document Object Model）。通过 HTML DOM，可访问 JavaScript HTML 文档的所有元素。 通过可编程的对象模型，JavaScript 获得了足够的能力来创建动态的 HTML。 JavaScript 能够改变页面中的所有 HTML 元素 JavaScript 能够改变页面中的所有 HTML 属性 JavaScript 能够改变页面中的所有 CSS 样式 JavaScript 能够对页面中的所有事件做出反应 查找 HTML 元素123456789// 通过 id 查找 HTML 元素var x=document.getElementById("intro");// 通过标签名查找 HTML 元素var x=document.getElementById("main");var y=x.getElementsByTagName("p");// 通过类名查找 HTML 元素var x=document.getElementsByClassName("intro"); DOM - 改变 HTML改变 HTML 输出流： 1234// 使用 HTML DOM 获得 id = "header" 的元素var element=document.getElementById("header");// 更改此元素的内容 (innerHTML)element.innerHTML="新标题"; 改变 HTML 属性： 123// 使用 HTML DOM 来获得 id="image" 的元素// 更改此元素的属性（把 "smiley.gif" 改为 "landscape.jpg"）document.getElementById("image").src="landscape.jpg"; 改变 HTML 样式： 123document.getElementById("p2").style.color="blue";document.getElementById("p2").style.fontFamily="Arial";document.getElementById("p2").style.fontSize="larger"; DOM 事件我们可以在事件发生时执行 JavaScript，比如当用户在 HTML 元素上点击时。 如需在用户点击某个元素时执行代码，请向一个 HTML 事件属性添加 JavaScript 代码： 当用户点击鼠标时 当网页已加载时 当图像已加载时 当鼠标移动到元素上时 当输入字段被改变时 当提交 HTML 表单时 当用户触发按键时 123456789101112131415161718function changetext(id) &#123; id.innerHTML="Ooops!";&#125;// 使用 DOM 分配事件document.getElementById("myBtn").onclick=function()&#123;displayDate()&#125;;// onload 和 onunload 事件会在用户进入或离开页面时被触发。// onload 事件可用于检测访问者的浏览器类型和浏览器版本，并基于这些信息来加载网页的正确版本。// onload 和 onunload 事件可用于处理 cookie。&lt;body onload="checkCookies()"&gt;// onchange 事件常结合对输入字段的验证来使用。// 下面是一个如何使用 onchange 的例子。当用户改变输入字段的内容时，会调用 upperCase() 函数。&lt;input type="text" id="fname" onchange="upperCase()"&gt;// onmouseover 和 onmouseout 事件可用于在用户的鼠标移至 HTML 元素上方或移出元素时触发函数。onmouseover="mOver(this)" onmouseout="mOut(this)" style="background-color:#D94A38;width:120px;height:20px;padding:40px;"&gt;Mouse Over Me DOM EventListeneraddEventListener( ) 方法用于向指定元素添加事件句柄。addEventListener( ) 方法添加的事件句柄不会覆盖已存在的事件句柄。 1234document.getElementById("myBtn").addEventListener("click", myFunction);function myFunction() &#123; alert ("Hello World!");&#125; 你可以向一个元素添加多个事件句柄。你可以向同个元素添加多个同类型的事件句柄，如：两个 “click” 事件。你可以向任何 DOM 对象添加事件监听，不仅仅是 HTML 元素。如： window 对象。 12345678910111213141516171819202122232425// 同个元素多个同类型事件var x = document.getElementById("myBtn");x.addEventListener("click", myFunction);x.addEventListener("click", someOtherFunction);function myFunction() &#123; alert ("Hello World!")&#125;function someOtherFunction() &#123; alert ("函数已执行!")&#125;// 同个元素多个不同类型事件var x = document.getElementById("myBtn");x.addEventListener("mouseover", myFunction);x.addEventListener("click", mySecondFunction);x.addEventListener("mouseout", myThirdFunction);function myFunction() &#123; document.getElementById("demo").innerHTML += "Moused over!&lt;br&gt;"&#125;function mySecondFunction() &#123; document.getElementById("demo").innerHTML += "Clicked!&lt;br&gt;"&#125;function myThirdFunction() &#123; document.getElementById("demo").innerHTML += "Moused out!&lt;br&gt;"&#125; 当你使用 addEventListener( ) 方法时, JavaScript 从 HTML 标记中分离开来，可读性更强， 在没有控制HTML标记时也可以添加事件监听。 你可以使用 removeEventListener( ) 方法来移除事件的监听。 3. Java 浏览器 BOM浏览器对象模型 (BOM) 使 JavaScript 有能力与浏览器”对话”。 Window 尺寸有三种方法能够确定浏览器窗口的尺寸。 123456789101112131415161718192021// 对于Internet Explorer、Chrome、Firefox、Opera 以及 Safari：window.innerHeight;window.innerWidth;// 对于 Internet Explorer 8、7、6、5：document.documentElement.clientHeight;document.documentElement.clientWidth;// 其他document.body.clientHeight;document.body.clientWidth;// 实例var w=window.innerWidth|| document.documentElement.clientWidth|| document.body.clientWidth;var h=window.innerHeight|| document.documentElement.clientHeight|| document.body.clientHeight;x=document.getElementById("demo");x.innerHTML="浏览器window宽度: " + w + ", 高度: " + h + "。" Window Screenwindow.screen 对象包含有关用户屏幕的信息。 1234document.write(screen.width + "*" + screen.height);document.write(screen.availWidth + "*" + screen.availHeight);document.write(screen.colorDepth);document.write(screen.pixelDepth); Window Locationwindow.location 对象用于获得当前页面的地址 (URL)，并把浏览器重定向到新的页面。 location.hostname 返回 web 主机的域名 location.pathname 返回当前页面的路径和文件名 location.port 返回 web 主机的端口 （80 或 443） location.protocol 返回所使用的 web 协议（http:// 或 https://） location.href 属性返回当前页面的 URL。 Window Historywindow.history 对象包含浏览器的历史。window.history对象在编写时可不使用 window 这个前缀。 为了保护用户隐私，对 JavaScript 访问该对象的方法做出了限制。 history.back( ) - 与在浏览器点击后退按钮相同history.forward( ) - 与在浏览器中点击向前按钮相同 12345678910&lt;html&gt;&lt;head&gt;&lt;script&gt;function goBack() &#123; window.history.back() &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt;&lt;input type="button" value="Back" onclick="goBack()"&gt;&lt;/body&gt;&lt;/html&gt; Window Navigatorwindow.navigator 对象包含有关访问者浏览器的信息。 1234567891011&lt;div id="example"&gt;&lt;/div&gt;&lt;script&gt;txt = "&lt;p&gt;浏览器代号: " + navigator.appCodeName + "&lt;/p&gt;";txt+= "&lt;p&gt;浏览器名称: " + navigator.appName + "&lt;/p&gt;";txt+= "&lt;p&gt;浏览器版本: " + navigator.appVersion + "&lt;/p&gt;";txt+= "&lt;p&gt;启用Cookies: " + navigator.cookieEnabled + "&lt;/p&gt;";txt+= "&lt;p&gt;硬件平台: " + navigator.platform + "&lt;/p&gt;";txt+= "&lt;p&gt;用户代理: " + navigator.userAgent + "&lt;/p&gt;";txt+= "&lt;p&gt;用户代理语言: " + navigator.systemLanguage + "&lt;/p&gt;";document.getElementById("example").innerHTML=txt;&lt;/script&gt; JavaScript 弹窗123456789101112131415161718// 确认框 confirm()function myFunction()&#123; var x; var r=confirm("按下按钮!"); if (r==true)&#123; x="你按下了\"确定\"按钮!"; &#125; else &#123; x="你按下了\"取消\"按钮!"; &#125;&#125;// 提示输入框 prompt()function myFunction()&#123; var x; var person=prompt("请输入你的名字","Harry Potter"); if (person!=null &amp;&amp; person!="")&#123; x="你好 " + person + "! 今天感觉如何?"; document.getElementById("demo").innerHTML=x; &#125;&#125; JavaScript CookieCookie 用于存储 web 页面的用户信息。Cookie 是一些数据, 存储于你电脑上的文本文件中。 当 web 服务器向浏览器发送 web 页面时，在连接关闭后，服务端不会记录用户的信息。 Cookie 的作用就是用于解决 “如何记录客户端的用户信息”: 当用户访问 web 页面时，他的名字可以记录在 cookie 中。在用户下一次访问该页面时，可以在 cookie 中读取用户访问记录。 123456789101112131415161718192021222324252627function setCookie(cname,cvalue,exdays)&#123; var d = new Date(); d.setTime(d.getTime()+(exdays*24*60*60*1000)); var expires = "expires="+d.toGMTString(); document.cookie = cname+"="+cvalue+"; "+expires;&#125;function getCookie(cname)&#123; var name = cname + "="; var ca = document.cookie.split(';'); for(var i=0; i&lt;ca.length; i++) &#123; var c = ca[i].trim(); if (c.indexOf(name)==0) return c.substring(name.length,c.length); &#125; return "";&#125;function checkCookie()&#123; var user=getCookie("username"); if (user!="")&#123; alert("Welcome again " + user); &#125; else &#123; user = prompt("Please enter your name:",""); if (user!="" &amp;&amp; user!=null)&#123; setCookie("username",user,30); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 基础]]></title>
    <url>%2F2017%2F12%2F13%2FJavaScript-Tutorial%2F</url>
    <content type="text"><![CDATA[HTML 中的脚本必须位于 &lt;script&gt; 与 &lt;/script&gt; 标签之间。脚本可被放置在 HTML 页面的 &lt;body&gt; 和 &lt;head&gt; 部分中，运行效果完全一致。 通常的做法是把函数放入 &lt;head&gt; 部分中，或者放在页面底部。这样就可以把它们安置到同一处位置，不会干扰页面的内容。 也可以把脚本保存到外部文件中。外部文件通常包含被多个网页使用的代码。如需使用外部文件，请在 &lt;script&gt; 标签的 src 属性中设置该 .js 文件： 12345&lt;script&gt;function displayDate()&#123; document.getElementById("demo").innerHTML=Date();&#125;&lt;/script&gt; HTML 定义了网页的内容，CSS 描述了网页的布局，JavaScript 网页的行为 JavaScript 是可插入 HTML 页面的编程代码 JavaScript 插入 HTML 页面后，可由所有的现代浏览器执行 1. JavaScript 输出 使用 window.alert( ) 弹出警告框 使用 document.write( ) 方法将内容写到 HTML 文档中 使用 innerHTML 写入到 HTML 元素 ( 如需从 JavaScript 访问某个 HTML 元素，您可以使用 document.getElementById(id) 方法。使用 “id” 属性来标识 HTML 元素，并 innerHTML 来获取或插入元素 ) 使用 console.log( ) 写入到浏览器的控制台 仅向 HTML 文档输出写内容： 123&lt;script&gt;document.write(Date());&lt;/script&gt; 整个 HTML 文档==将被覆盖==： 12345&lt;script&gt;function myFunction() &#123; document.write(Date());&#125;&lt;/script&gt; 2. JavaScript 变量、数据类型、对象JavaScript 数据类型：12345var length = 16; // Number 通过数字字面量赋值 var points = x * 10; // Number 通过表达式字面量赋值var lastName = "Johnson"; // String 通过字符串字面量赋值var cars = ["Saab", "Volvo", "BMW"]; // Array 通过数组字面量赋值var person = &#123;firstName:"John", lastName:"Doe"&#125;; // Object 通过对象字面量赋值 类型转换： 1234567891011121314151617String(x) // 将变量 x 转换为字符串并返回String(123) // 将数字 123 转换为字符串并返回String(100 + 23) // 将数字表达式转换为字符串并返回obj = new Date()obj.toString() // 返回Wed Dec 13 2017 20:29:09 GMT+0800 (CST)parseFloat() // 解析一个字符串，并返回一个浮点数parseInt() // 解析一个字符串，并返回一个整数自动转换为字符串当你尝试输出一个对象或一个变量时 JavaScript 会自动调用变量的 toString() 方法：document.getElementById("demo").innerHTML = myVar;// if myVar = &#123;name:"Fjohn"&#125; // toString 转换为 "[object Object]"// if myVar = [1,2,3,4] // toString 转换为 "1,2,3,4"// if myVar = new Date() // toString 转换为 "Fri Jul 18 2014 09:08:55 GMT+0200" Number 方法 toString( ) 也是有同样的效果。 返回构造函数： 1234567"John".constructor // 返回函数 String() &#123; [native code] &#125;(3.14).constructor // 返回函数 Number() &#123; [native code] &#125;false.constructor // 返回函数 Boolean() &#123; [native code] &#125;[1,2,3,4].constructor // 返回函数 Array() &#123; [native code] &#125;&#123;name:'John', age:34&#125;.constructor // 返回函数 Object() &#123; [native code] &#125;new Date().constructor // 返回函数 Date() &#123; [native code] &#125;function () &#123;&#125;.constructor // 返回函数 Function()&#123; [native code] &#125; Javascript 对象对象也是一个变量，但对象可以包含多个值（多个变量） 12var car = &#123;type:"Fiat", model:500, color:"white"&#125;;var person = &#123;firstName:"John", lastName:"Doe", age:50, eyeColor:"blue"&#125;; JavaScript 对象是键值对的容器。键值对通常写法为 name : value (键与值以冒号分割)。键值对在 JavaScript 对象通常称为 对象属性。 访问对象属性的两种方式：person.lastname; person[&quot;lastName&quot;]; Javascript 函数可以在某事件发生时直接调用函数（比如当用户点击按钮时），并且可由 JavaScript 在任何位置进行调用。 12345function functionname() &#123; 执行代码 &#125;// examplefunction myFunction(a,b) &#123; return a*b; &#125;document.getElementById("demo").innerHTML=myFunction(4,3); JavaScript 变量作用域： 12345678910111213141516171819函数内局部变量：// 此处不能调用 carName 变量function myFunction() &#123; var carName = "Volvo"; // 函数内可调用 carName 变量&#125;全局变量：var carName = " Volvo";// 此处可调用 carName 变量function myFunction() &#123; // 函数内可调用 carName 变量&#125;如果变量在函数内没有声明（没有使用 var 关键字），该变量为全局变量。以下实例中 carName 在函数内，但是为全局变量。// 此处可调用 carName 变量 function myFunction() &#123; carName = "Volvo"; // 此处可调用 carName 变量&#125; JavaScript 变量提升 JavaScript 中，函数及变量的声明都将被提升到函数的最顶部，因此，变量可以在使用后声明，也就是变量可以先使用再声明。==JavaScript 只有声明的变量会提升，初始化的不会== 1234567891011var x = 5; // 初始化 xelem = document.getElementById("demo"); // 查找元素 elem.innerHTML = x + " " + y; // 显示 x 和 yvar y = 7; // 初始化 y，实例 2 的 y 输出了 undefined，这是因为变量声明 (var y) 提升了，但是初始化(y = 7) 并不会提升，所以 y 变量是一个未定义的变量。// 类似于以下代码：var x = 5; // 初始化 xvar y; // 声明 yelem = document.getElementById("demo"); // 查找元素elem.innerHTML = x + " " + y; // 显示 x 和 yy = 7; // 设置 y 为 7 局部变量在函数执行完毕后销毁。全局变量在页面关闭后销毁。 JavaScript 事件当在 HTML 页面中使用 JavaScript 时，JavaScript 可以触发这些事件。HTML 事件可以是浏览器行为，也可以是用户行为，如：HTML 页面完成加载、HTML input 字段改变时、HTML 按钮被点击。 123&lt;button onclick="getElementById('demo').innerHTML=Date()"&gt;现在的时间是?&lt;/button&gt;&lt;button onclick="this.innerHTML=Date()"&gt;现在的时间是?&lt;/button&gt;&lt;button onclick="displayDate()"&gt;现在的时间是?&lt;/button&gt; 3. JavaScript 流程控制12345678910111213141516171819202122232425262728// if-else 语句if (condition1) &#123; 当条件 1 为 true 时执行的代码&#125; else if (condition2) &#123; 当条件 2 为 true 时执行的代码&#125; else &#123; 当条件 1 和 条件 2 都不为 true 时执行的代码&#125;// switch 语句switch(n) &#123; case 1: 执行代码块 1 break; case 2: 执行代码块 2 break; default: 与 case 1 和 case 2 不同时执行的代码&#125;// for 循环for (var i=0;i&lt;cars.length;i++） &#123; document.write(cars[i] + "&lt;br&gt;");&#125;// while 循环while (i&lt;5) &#123; x=x + "The number is " + i + "&lt;br&gt;"; i++;&#125; 4. JavaScript 表单验证123456789function validateForm() &#123; var x = document.forms["myForm"]["email"].value; var atpos = x.indexOf("@"); var dotpos = x.lastIndexOf("."); if (atpos &lt; 1 || dotpos &lt; atpos + 2 || dotpos + 2 &gt;= x.length) &#123; alert("不是一个有效的 e-mail 地址"); return false; &#125;&#125; 5. JavaScript JSON JSON 是用于存储和传输数据的格式 JSON 通常用于服务端向网页传递数据 JSON 格式化后为 JavaScript 对象 1234&#123;"sites":[ &#123;"name":"Google", "url":"www.google.com"&#125;, &#123;"name":"Taobao", "url":"www.taobao.com"&#125;]&#125; JSON 语法规则： 数据为 键/值 对，数据由逗号分隔，==大括号保存对象，方括号保存数组== 为 JSON 字符串创建对象： 1234567var text = '&#123; "sites" : [' + '&#123; "name":"Runoob" , "url":"www.runoob.com" &#125;,' + '&#123; "name":"Google" , "url":"www.google.com" &#125;,' + '&#123; "name":"Taobao" , "url":"www.taobao.com" &#125; ]&#125;'; obj = JSON.parse(text);document.getElementById("demo").innerHTML = obj.sites[1].name + " " + obj.sites[1].url; Others：href=”#” 与 href=”javascript:void(0)” 的区别： #包含了一个位置信息，默认的锚是 #top 也就是网页的上端。而javascript:void(0), 仅仅表示一个死链接。在页面很长的时候会使用 # 来定位页面的具体位置，格式为：# + id。 如果你要定义一个死链接请使用 javascript:void(0) 代码规范： 大多 Web 服务器 (Apache, Unix) 对大小写敏感： london.jpg 不能通过 London.jpg 访问。 其他 Web 服务器 (Microsoft, IIS) 对大小写不敏感： london.jpg 可以通过 London.jpg 或 london.jpg 访问。 必须保持统一的风格，建议统一使用小写的文件名。]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>前端</tag>
        <tag>JavaScript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Head First HTML & CSS]]></title>
    <url>%2F2017%2F12%2F13%2FHead-First-HTML-CSS%2F</url>
    <content type="text"><![CDATA[1. Elements:&lt;em&gt; &lt;/em&gt; 斜体 &lt;strong&gt; &lt;/strong&gt;加粗 &lt;blockquote&gt; &lt;/blockquote&gt; 段引用block 元素：&lt;h1&gt; &lt;ul&gt; &lt;li&gt; &lt;ol&gt; &lt;blockquote&gt;inline 元素：&lt;em&gt; &lt;img&gt; &lt;q&gt; 图片链接： &lt;a&gt; &lt;/a&gt; 内嵌 img 元素 2.CSS Id 和 Class id 选择器可以为标有 ==特定 id 的 HTML 元素== 指定特定的样式。HTML 元素以 id 属性来设置 id 选择器, CSS 中 id 选择器以 “#” 来定义。 class 选择器用于描述 ==一组元素的样式==，class 选择器有别于id选择器，class可以在 ==多个元素== 中使用。class 选择器在 HTML 中以 class 属性表示, 在 CSS 中，类选择器以一个点”.”号显示。 3.插入样式表的方法： 外部样式表，当样式表需要用于很多页面时 123&lt;head&gt;&lt;link rel="stylesheet" type="text/css" href="mystyle.css"&gt;&lt;/head&gt; 内部样式表，当单个文档需要特殊的样式时 123456789101112&lt;head&gt;&lt;style&gt;body &#123; background-color: linen;&#125;h1 &#123; color: maroon; margin-left: 40px;&#125; &lt;/style&gt;&lt;/head&gt; 内联样式，当样式仅需要在一个元素上应用一次时 1&lt;h1 style="color:blue;margin-left:30px;"&gt;This is a heading&lt;/h1&gt; 多重样式优先级：内联样式）Inline style &gt; （内部样式）Internal style sheet &gt;（外部样式）External style sheet &gt; 浏览器默认样式 4. CSS 文本与字体字体系列 font-family font-family 属性应该设置几个字体名称作为一种”后备”机制，如果浏览器不支持第一种字体，他将尝试下一种字体。 注意: 如果字体系列的名称超过一个字，它必须用引号，如 Font Family：”Times New Roman”。 使用 Web 字体：Google Fonts使用 Woff 字体：Homepage of THE VERGE字体大小：像素、百分比、倍数、关键字 1234body &#123; font-size: 14px; &#125;h1&#123; font-size: 150%; &#125;h2&#123; font-size: 1.2em; &#125; (倍数)h3&#123; font-size: small/large; &#125; 推荐方式：（ 后续只需改动body） 选择一个关键字（small 或 medium），指定其作为 body 规则中的字体大小。这相当于页面默认的字体大小。使用 em 或百分数，相对于 body 字体大小指定其他元素的字体大小。 改变字体粗细：font-weightnormal, bold, lighter 增加字体风格：font-styleitalic（自带斜体风格）, oblique（浏览器将正常文字倾斜） 字体颜色定义： 直接命名：silver, maroon, purple RGB（80%, 40%, 0%）RGB（204, 102, 0） 十六进制：#cc(R)66(G)00(B) 一组颜色分量的两位数字相同，可以缩写成一位数字，#cc6600 = #c60 文本对齐方式文本排列属性是用来设置文本的水平对齐方式。文本可居中或对齐到左或右,两端对齐。当text-align设置为”justify”，每一行被展开为宽度相等，左，右外边距是对齐（如杂志和报纸）。 123h1 &#123;text-align:center;&#125;p.date &#123;text-align:right;&#125;p.main &#123;text-align:justify;&#125; 文本装饰与大小写转换： 123text-decoration: line-through;text-decoration: underline;text-decoration: overline; 123p.uppercase &#123;text-transform:uppercase;&#125;p.lowercase &#123;text-transform:lowercase;&#125;p.capitalize &#123;text-transform:capitalize;&#125; font-variant 属性 1p.small &#123; font-variant:small-caps; &#125; font-variant 属性设置小型大写字母的字体显示文本，这意味着所有的小写字母均会被转换为大写，但是所有使用小型大写字体的字母与其余文本相比，其字体尺寸更小 5. CSS 背景 background 简写属性，作用是将背景属性设置在一个声明中。 background-attachment 背景图像是否固定或者随着页面的其余部分滚动。 background-color 设置元素的背景颜色。 background-image 把图像设置为背景。 background-position 设置背景图像的起始位置。 background-repeat 设置背景图像是否及如何重复。 123456789&lt;style&gt;body&#123; background-image:url('img_tree.png'); background-repeat:no-repeat; background-position:right top; margin-right:200px;&#125;&lt;/style&gt; 6. CSS Box Model / BorderCSS盒模型本质上是一个盒子，封装周围的HTML元素，它包括：边距，边框，填充，和实际内容。盒模型允许我们在其它元素和周围元素边框之间的空间放置元素。 Margin(外边距) - 清除边框外的区域，==外边距是透明的==。 Border(边框) - 围绕在内边距和内容外的边框。 Padding(内边距) - 清除内容周围的区域，==内边距是透明的==。 Content(内容) - 盒子的内容，显示文本和图像，内容与盒子边缘之间没有空间 123456789101112131415line-height: 1.9em;font-style: italic;font-family: Georgia, "Times New Roman", Times, serif;color: #444444;border-color: white;border-width: 2px;border-style: dashed;background-color: #a7cece;padding: 25px;padding-left: 80px;margin: 30px;margin-right: 250px;background-image: url(images/background.gif);background-repeat: no-repeat;background-position: top left; 8种边框样式：CSS 元素 Display(显示) 与 Visibility（可见性） 隐藏一个元素可以通过把display属性设置为”none”，或把visibility属性设置为”hidden”。 visibility：hidden可以隐藏某个元素，但隐藏的元素仍需占用与未隐藏之前一样的空间。也就是说，该元素虽然被隐藏了，但仍然会影响布局。 display：none可以隐藏某个元素，且隐藏的元素不会占用任何空间。也就是说，该元素不但被隐藏了，而且该元素原本占用的空间也会从页面布局中消失。 block 元素与 inline 元素的显示互换 123456789101112131415&lt;style&gt;span &#123; display:block; &#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;h2&gt;Nirvana&lt;/h2&gt;&lt;span&gt;Record: MTV Unplugged in New York&lt;/span&gt;&lt;span&gt;Year: 1993&lt;/span&gt;&lt;/body&gt;Output：NirvanaRecord: MTV Unplugged in New YorkYear: 1993 7. CSS 定位、浮动、对齐 relative 定位：相对定位元素的定位是相对其正常位置。 absolute 定位：绝对定位的元素的位置相对于最近的已定位父元素，如果元素没有已定位的父元素，那么它的位置相对于 overflow：设置当元素的内容溢出其区域时发生的事情（auto、hidden、scroll、visible、inherit） CSS 的 Float，会使元素向左或向右移动，其周围的元素也会重新排列。Float（浮动），往往是用于图像，但它在布局时一样非常有用。 清除浮动 - 使用 clear。元素浮动之后，周围的元素会重新排列，为了避免这种情况，使用 clear 属性。clear 属性指定元素两侧不能出现浮动元素。 8. CSS 导航栏导航栏 = 链接列表 导航条基本上是一个链接列表，所以使用 &lt;ul&gt; 和 &lt;li&gt; 元素非常有意义 链接样式： 1234a:link &#123;color:#000000;&#125; /* 未访问链接*/a:visited &#123;color:#00FF00;&#125; /* 已访问链接 */a:hover &#123;color:#FF00FF;&#125; /* 鼠标移动到链接上 */a:active &#123;color:#0000FF;&#125; /* 鼠标点击时 */ Ex. 全屏高度固定导航条： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;html&gt;&lt;head&gt;&lt;meta charset="utf-8"&gt;&lt;style&gt;body &#123; margin: 0;&#125;ul &#123; list-style-type: none; margin: 0; padding: 0; width: 25%; background-color: #f1f1f1; position: fixed; height: 100%; overflow: auto;&#125;li a &#123; display: block; color: #000; padding: 8px 16px; text-decoration: none;&#125;li a.active &#123; background-color: #4CAF50; color: white;&#125;li a:hover:not(.active) &#123; background-color: #555; color: white;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;ul&gt; &lt;li&gt;&lt;a class="active" href="#home"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#news"&gt;新闻&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#contact"&gt;联系&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a href="#about"&gt;关于&lt;/a&gt;&lt;/li&gt;&lt;/ul&gt;&lt;div style="margin-left:25%;padding:1px 16px;height:1000px;"&gt;......&lt;/div&gt;&lt;/body&gt;&lt;/html&gt; 水平导航栏： 有两种方法创建横向导航栏。使用内联(inline)或浮动(float)的列表项。这两种方法都很好，但如果想链接到具有相同的大小，必须使用浮动的方法。 9. CSS 媒体Image Gallary 1234567891011121314151617181920212223242526272829303132333435363738394041424344&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;head&gt;&lt;style&gt;div.gallery &#123; margin: 5px; border: 1px solid #ccc; float: left; width: 180px;&#125;div.gallery:hover &#123; border: 1px solid #777; /* 鼠标放上时增加边框 */&#125;div.gallery img &#123; width: 100%; height: auto;&#125;div.desc &#123; padding: 15px; /* 文本描述部分的 padding */ text-align: center;&#125;&lt;/style&gt;&lt;/head&gt;&lt;body&gt;&lt;div class="gallery"&gt; &lt;a target="_blank" href="img_fjords.jpg"&gt; &lt;img src="img_fjords.jpg" alt="Trolltunga Norway" width="300" height="200"&gt; &lt;/a&gt; &lt;div class="desc"&gt;Add a description of the image here&lt;/div&gt;&lt;/div&gt;&lt;div class="gallery"&gt; &lt;a target="_blank" href="img_forest.jpg"&gt; &lt;img src="img_forest.jpg" alt="Forest" width="600" height="400"&gt; &lt;/a&gt; &lt;div class="desc"&gt;Add a description of the image here&lt;/div&gt;&lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>JavaWeb</tag>
        <tag>前端</tag>
        <tag>CSS</tag>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 必知必会 Part II]]></title>
    <url>%2F2017%2F12%2F07%2FMySQL-Crash-Course-Part-II%2F</url>
    <content type="text"><![CDATA[1. 数据插入 INSERT用来插入或添加行到数据表，比如插入完整的行，插入行的一部分，插入多行，插入某些查询的结果。 插入完整的行要求指定表名和被插入到新行中的值，对每个列必须提供一个值（没有值可以使用 NULL ）且各个列必须以它们在表定义中出现的次序填充。INSERT INTO customers VALUS (NULL, &#39;Pep E. LaPew&#39;, &#39;100 Main Street&#39;, &#39;Los Angeles&#39;, &#39;CA&#39;, &#39;90046&#39;, &#39;USA&#39;, NULL, NULL) 由于上述语法高度依赖于表中列的定义次序，因此并不保证下一次表结构变动后各个列保持完全相同的次序，并不安全。更安全但繁琐的方法如下，即给定对应的列名INSERT INTO customers(cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country, cust_contact, cust_email) VALUES(&#39;Pep E. LaPew&#39;, &#39;100 Main Street&#39;, &#39;Los Angeles&#39;, &#39;CA&#39;, &#39;90046&#39;, &#39;USA&#39;, NULL, NULL); 给定列名时，如果表的定义允许，可以在 INSERT 语句中省略某些列，如果该列定义允许 NULL 值或该列有默认值；如果不满足以上条件，插入不成功。 提高整体性能 数据库经常被多个客户端访问，对处理什么请求以及用什么次序处理进行管理是 MySQL 的任务，INSERT 操作可能很耗时，而且可能降低等待处理的 SELECT 语句的性能，因此可以在 INSERT 和 INTO 之间插入关键字LOW_PRIORITY 插入多行使用多条 INSERT 语句或者当每条语句的列名和次序都相同时，可以使用组合语句，用单条 INSERT 语句处理多个插入比使用多条语句快。INSERT INTO customers( ) VALUES ( ), ( ), ( ); 插入检索出来的数据由一条 SELECT 语句和一条 INSERT 语句组成INSERT INTO customers(cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country) SELECT cust_id, cust_contact, cust_email, cust_name, cust_address, cust_city, cust_state, cust_zip, cust_country FROM custnew; INSERT SELECT 中 SELECT 语句也可以包含 WHERE 子句以过滤插入的数据 2. 更新和删除数据更新和修改表中的数据，可使用 UPDATE 语句更新表中特定行或所有行。UPDATE 语句由 要更新的表、列名和它们的新值、确定要更新行的过滤条件 三部分组成。 Ex. 客户 10005 有了新的邮件地址需要更新：UPDATE customers SET cust_email = &#39;elmer@fudd.com&#39; WHERE cust_id = 10005; WHERE 语句作为结束，告诉 MySQL 更新哪一行 更新多个列的语法稍有不同UPDATE customers SET cust_name = &#39;The Fudds&#39;, cust_email = &#39;elmer@fudd.com&#39; WHERE cust_id = 10005; 如果用 UPDATE 语句更新多行中一行出现错误，整个 UPDATE 操作会被取消，可以用 IGNORE 关键字来在发生错误时继续更新 删除数据从表中删除一行或多行DELETE FROM customers WHERE cust_id = 10006; DELETE 不需要列名或通配符，因为其删除整行而不是整列，删除指定的整列需要使用 UPDATE 语句将该列设为 NULL UPDATE customers SET cust_state = NULL; 如果想从表中删除所有行，不要使用 DELETE 语句而要使用 TRUNCATE TABLE 语句，它完成相同的工作而且更快，实际上是删除原来的表并重建一个同名新表 3. 创建和操纵表用 CREATE TABLE 语句创建新表必须给出新表的名字，表列的名字和定义，数据类型，主键列，是否使用 NULL 值等 新表无法覆盖原来存在的同名表，必须手动删除它才能创建新表 正如所述，主键值必须唯一。即表中的每个行必须具有唯一的主键值。如果主键使用单个列，则它的值必须唯一。如果使用多个列，则这些列的组合值必须唯一。 使用 AUTO_INCREMENT每个表只允许一个 AUTO_INCREMENT 列，而且它必须被索引（比如使它成为主键）。SELECT last_insert_id( ) 函数返回最后一个AUTO INCREMENT 值，可以用于后续的 MySQL语句。 更新表更新表定义可使用 ALTER TABLE 语句，但理想状态下，表中存储数据之后就不应该再被更新。 给表添加一个列：ALTER TABLE vendors ADD vend_phone CHAR(20); 删除刚刚添加的列：ALTER TABLE vendors DROP COLOMN vend_phone; 删除表 DROP TABLE customers;重命名表 RENAME TABLE customers2 TO customers;4. 视图视图可以重用 SQL 语句；简化复杂的 SQL 操作。在编写查询后，可以方便地重用它而不必知道它的基本查询细节；使用表的组成部分而不是整个表；保护数据；可以给用户授予表的特定部分的访问权限而不是整个表的访问权限；更改数据格式和表示。视图可返回与底层表的表示和格式不同的数据。 视图的规则和限制与表一样，视图必须唯一命名（不能给视图取与别的视图或表相同的名字）。对于可以创建的视图数目没有限制。为了创建视图，必须具有足够的访问权限。这些限制通常由数据库管理人员授予。视图可以嵌套，即可以利用从其他视图中检索数据的查询来构造一个视图。ORDER BY 可以用在视图中，但如果从该视图检索数据 SELECT 中也含有 ORDER BY，那么该视图中的 ORDER BY 将被覆盖。视图不能索引，也不能有关联的触发器或默认值。视图可以和表一起使用。例如，编写一条联结表和视图的 SELECT 语句。 利用视图简化复杂联结CREATE VIEW productcustomers AS SELECT cust_name, cust_contact, prod_id FROM customers, orders, orderitems WHERE customers.cust_id = orders.cust_id AND orderitems.order_num = orders.order_num; 从视图中检索订购了 TNT2 的客户： 用视图过滤不想要的数据CREATE VIEW customermaillist AS SELECT cust_id, cust_name, cust_email FROM customers WHERE cust_mail IS NOT NULL; End Of Part II]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Think Different]]></title>
    <url>%2F2017%2F12%2F06%2FThink-Different%2F</url>
    <content type="text"><![CDATA[Here’s to the crazy ones. The misfits. The rebels. The trouble-makers. The round pegs in the square holes. The ones who see things differently. They’re not fond of rules, and they have no respect for the status-quo. You can quote them, disagree with them, glorify, or vilify them. But the only thing you can’t do is ignore them. Because they change things. They push the human race forward. And while some may see them as the crazy ones, we see genius. Because the people who are crazy enough to think they can change the world, are the ones who do. —Apple (function(){var player = new DPlayer({"container":document.getElementById("dplayer0"),"theme":"#FADFA3","loop":true,"video":{"url":"http://oxgw3nd2b.bkt.clouddn.com/Apple%20Steve%20Jobs%20The%20Crazy%20Ones%20-%20NEVER%20BEFORE%20AIRED%201997%20-%20%28Original%20Post%29.mp4","pic":"http://oxgw3nd2b.bkt.clouddn.com/thinkdifferent.jpg"}});window.dplayers||(window.dplayers=[]);window.dplayers.push(player);})()]]></content>
      <categories>
        <category>科技</category>
      </categories>
      <tags>
        <tag>Apple</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[MySQL 必知必会 Part I]]></title>
    <url>%2F2017%2F12%2F06%2FMySQL-Crash-Course-Part-I%2F</url>
    <content type="text"><![CDATA[1. 主键 primary key:唯一能够区分表中每个行（订单ID 雇员ID security ID） · 任意两行都不具有相同的主键值；每个行都必须具有一个主键值（不允许 NULL ）；使用多个列作为主键时，所有列值的组合必须是唯一的（单个列的值可以不唯一）；不更新主键列中的值；不重用主键列的值；不在主键列中使用可能会更改该的值。 2. 数据库结构 row coloumnColumns 包含字段名、数据类型、是否允许 NULL、键信息、默认值以及其他信息（auto_increment–id类似字段的自动增量）。 3. 检索语句 SELECT· 选择多列，列名之间加逗号 · 检索有不同值的列使用 DISTINCT 关键字，此关键字指示 MySQL 只返回不同的值。DISTINCT 关键字应用于所有列。 · 限制结果可使用 LIMIT 子句，SELECT prod_name FROM products LIMIT 5; 要得出下一个 5 行，可以指定开始行和行数，SELECT prod_name FROM products LIMIT 5,5; ==检索出来的第一行是 0 而不是 1== · MySQL 5 开始支持另一种语法 OFFSET，即 LIMIT 3,4 = LIMIT 4 OFFSET 3 · 完全限定表名与列名SELECT products.prod_name FROM crAShcourse.products; 4. 排序语句 ORDER BY· 单列排序排序列可以是 SELECT 的也可以是非 SELECT 的SELECT prod_name FROM products ORDER BY prod_name;SELECT prod_name, prod_id FROM products ORDER BY prod_price; · 多列排序SELECT prod_name, prod_id, prod_price FROM products ORDER BY prod_name, prod_id; · 升降 DESC/ASC只对关键字前的一列有效，如果要对多列进行升降排序，需要为每列指定 DESC/ASC 关键字（Dicionary 类数据库排序中，A = a，其他需要请求 DBA 帮助） · ORDER BY 需位于 FROM 后, LIMIT 需位于 ORDER BY 后5. 过滤数据语句 WHERESELECT prod_name, prod_id FROM products WHERE prod_price = 2.5; · 同时使用 ORDER BY 和 WHERE 时，ORDER BY 需要位于 WHERE 后 · 空值检查NULL 与包含 0、空字符串或仅仅包含空格不同SELECT prod_name FROM products WHERE prod_price is NULL; · 数据过滤操作符= != &lt;&gt; &lt;= &gt;= &gt; &lt; BETWEEN AND ####· AND OR 逻辑操作符AND 优先级更高，搭配 OR 使用需要圆括号SELECT prod_name, prod_price FROM products WHERE (vend_id = 1002 OR vend_id = 1003) and prod_price &gt;=10; · 操作符 OR 与 IN 相同vend_id = 1002 OR vend_id = 1003 等同于 vend_id IN (1002,1003) IN 操作符语法更清楚直观，计算次序更容易管理，执行更快，可以包含其他 SELECT 子句 · NOT 操作符，有且仅有一个功能，否定它之后跟的任何条件。MySQL 中的 NOT 语句支持对 IN、BETWEEN、EXISTS 语句取反6. 通配符过滤 LIKE· %通配符任何字符出现的任意次数，% 代表搜索中给定位置的 0 个、1 个或多个字符，但不能匹配 NULL SELECT prod_name FROM products WHERE prod_name LIKE &#39;jet%&#39;; 检索以 jet 开头、后跟任意字符的词SELECT prod_name FROM products WHERE prod_name LIKE &#39;%jet%&#39;; 检索以任意字符开头和结尾，中间包含 jet 的词 · (_)下划线通配符用途与%一样，但匹配单个字符而非多个字符，其中搜索 1 要求匹配两个通配符，因此 .5 ton anvil 不显示；与 % 能够匹配 0 个字符不同，_只能匹配一个字符，不能多也不能少 7. 正则表达式 REGEXP· 需要大小写时用 BINARYSELECT prod_name FROM products WHERE prod_name REGEXP BINARY &#39;TON&#39;; · 进行 OR 匹配用 “ | ”，多个 “ | ” 可并入多个正则表达式SELECT prod_name FROM products WHERE prod_name REGEXP &#39;anvil|et&#39;; · 匹配几个字符之一&#39;[123] ton&#39; 为 &#39;[1|2|3] ton&#39; 的缩写，不等于 &#39;1|2|3 ton&#39;匹配范围时，[0123456789] 等同于 [0-9]，同样的，[a-z] 可以匹配所有字母匹配特殊字符时，使用 \\ 进行前导，如默认情况下 &#39;.&#39; 匹配所有结果，而 &#39;\\.&#39; 只匹配含有 “.” 的记录 · 匹配多个实例需要解说一下，\\(匹配 (，[0-9] 匹配任意数字（这个例子中为 1 和 5), sticks？ 匹配 stick 和 sticks (s 后的 ？ 使 s 可选，因为 ？ 匹配它前面的任何字符的 0 次或 1 次出现，\\) 匹配)。没有 ？，匹配 stick 和 sticks 会非常困难。 分析如前所述，[:digit:] 匹配任意数字，因而它为数字的一个集合。{4} 确切地要求它前面的字符（任意数字）出现 4 次，所以 [[:digit:]] {4} 匹配连在一起的任意 4 位数字。 · 定位符：匹配 特定位置 的文本^ 文本的开始、$ 文本的结尾、[[:&lt;:]] 词的开始、[[:&gt;:]] 词的结尾 8. 创建计算字段如果想在一个字段中既显示公司名，又显示公司的地址，但这两个信息一般包含在不同的表列中。城市、州和邮政编码存储在不同的列中（应该这样），但邮件标签打印程序却需要把它们作为一个恰当格式的字段检索出来。列数据是大小写混合的，但报表程序需要把所有数据按大写表示出来。 Vendors 表包含供应商名和位置信息。假如要生成一个供应商报表，需要在供应商的名字中按照 name (location） 这样的格式列出供应商的位置。此报表需要单个值，而表中数据存储在两个列 vend_name 和 vend_country 中。此外，需要用括号将 vend_country 括起来，这些东西都没有明确存储在数据库表中。 Concat( )RTrim( ) LRrim( ) 去掉左右两边的空格使用别名：SELECT Concat(RTrim(vend_name), &#39; (&#39;, RTrim(vend_COUNTry), &#39;)&#39;) AS vend_title FROM vendors; 并不新建一个列 执行计算：SELECT prod_id, quantity, item_price, quantity*item_price AS expanded_price FROM orderitems WHERE order_num = 20005; 可以用圆括号来限制运算符执行顺序 9. 使用数据处理函数函数没有 SQL 语句的可移植性强，使用时应做好代码注释 · 文本处理函数 MySQL 5.7 StrINg FunctionsUpper( ) 将文本转换为大写、Soundex( ) 返回文本串为描述其语音表示的字母数字模式 · 时间日期处理函数 MySQL 5.7 Data and Time Functions处理 period of time 的几种方法:SELECT cust_id, order_num FROM orders WHERE Date(order_date) BETWEEN &#39;2005-09-01&#39; AND &#39;2005-09-30&#39;;SELECT cust_id, order_num FROM orders WHERE Year(order_date) = 2005 AND Month(order_date) = 9; · 汇总函数 AVG( ) SUM( ) COUNT( ) MIN( ) MAX( )COUNT( ) 忽略 NULLMAX( ) 可以用于文本，如果数据按相应的列排序，MAX( ) 返回最后一行MIN( ) 可以用于文本，如果数据按相应的列排序，MIN( ) 返回最前面的行，并忽略 NULL 值 SUM( ) 可以用来合计计算值，忽略 NULL 值 SELECT SUM(item_price*quantity) AS total_price FROM orderitems WHERE order_num = 20005; AVG( ) 可以使用 DISTNCT 函数，只返回不同价格 produc 的价格平均值（2.5，10 只计算一个） SELECT avg(distINct prod_price) AS avg FROM products WHERE vend_id = 1003;如果指定列名，则 DISTINCT 只能用于 COUNT（ ）。DISTINCT不能用于 COUNT（*），因此不允许使用 COUNT (DISTINCT），否则会产生错误。类似地，DISTINCT 必须使用列名，不能用于计算或表达式。 组合聚集函数：SELECT 可根据需要包含多个聚集函数 · 分组数据SELECT vend_id, COUNT(*) AS num_prods FROM products GROUP BY vend_id; · GROUP BY 子句可以包含任意数目的列。这使得能对分组进行嵌套，为数据分组提供更细致的控制。· 如果在 GROUP BY 子句中嵌套了分组，数据将在最后规定的分组上进行汇总。换句话说，在建立分组时，指定的所有列都一起计算（所以不能从个别的列取回数据）。· GROUP BY 子句中列出的每个列都必须是检索列或有效的表达式（但不能是聚集函数）。如果在 SELECT 中使用表达式，则必须在 GROUP BY 子句中指定相同的表达式。不能使用别名。· 除聚集计算语句外，SELECT 语句中的每个列都必须在 GROUP BY 子句中给出。· 如果分组列中具有 NULL 值，则 NULL 将作为一个分组返回。如果列中有多行 NULL 值，它们将分为一组。· GROUP BY 子句必须出现在 WHERE 子句之后，ORDER BY 子句之前。 WHERE 过滤行，HAVING 过滤分组SELECT cust_id ,COUNT(*) AS orders FROM orders GROUP BY cust_id HAVING COUNT(*) &gt;= 2; 中，WHERE 不起作用· 分组排序 GROUP BY / ORDER BY SELECT 子句顺序 说明 是否必须使用 SELECT 要返回的列或表达式 是 FROM 从中检索数据的表 仅在从表选择数据时使用 WHERE 行级过滤 否 GROUP BY 分组说明 仅在按组计算聚集时使用 HAVING 组级过滤 否 ORDER BY 输出排序顺序 否 LIMIT 要检索的行数 否 10. 使用子查询SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;);SELECT cust_name, cust_contact FROM customers WHERE cust_id IN (SELECT cust_id FROM orders WHERE order_num IN (SELECT order_num FROM orderitems WHERE prod_id = &#39;TNT2&#39;)); · 作为计算字段使用子查询，需要限定列名SELECT cust_name, cust_state, (SELECT COUNT(*) FROM orders WHERE orders.cust_id = customers.cust_id) AS orders FROM customers ORDER BY cust_name; 11. 联结（Join）表· 检索的两个列分别位于两个表中，需要完全限定列名SELECT vend_name, prod_name, prod_price FROM vendors, products WHERE vendors.vend_id = products.vend_id ORDER BY vend_name, prod_name; · 笛卡儿积（cartesian product）由没有联结条件的表关系返回的结果为笛卡儿积。检索出的行的数目将是第一个表中的行数乘以第二个表中的行数。 · 联结多个表SELECT prod_name, vend_name, prod_price, quantity FROM orderitems, products, vendors WHERE products.vend_id = vendors.vend_id and orderitems.prod_id = products.prod_id and order_num = 20005; · 自联结查询 products 表中供应商与商品名为 ‘DRNTR’ 相同的商品 · 外部联结 LEFT/RIGHT OUTER JOIN ON必须使用 LEFT/RIGHT 关键字指定包含所有行的表； · 使用 UNION 求两个 SELECT 语句的并集不管查询结构是否包含重复，可简化复杂语句的 WHERE 操作SELECT vend_id, prod_id, prod_price FROM products WHERE prod_price &lt;= 5 UNION SELECT vend_id, prod_id, prod_price FROM products WHERE vend_id IN (1001, 1002) ORDER BY vend_id, prod_price; 12. 使用全文本搜索在创建表时启用全文本搜索支持 FULLTEXT( ) . 使用查询扩展这次返回了 7 行。第一行包含词 anvils，因此等级最高。第二分析行与 anvils 无关，但因为它包含第一行中的两个词（customer 和 recommend），所以也被检索出来。第 3 行也包含这两个相同的词，但它们在文本中的位置更靠后且分开得更远，因此也包含这一行，但等级为第三。第三行确实也没有涉及 anvils（按它们的产品名）。正如所见，查询扩展极大地增加了返回的行数，但这样做也增加了你实际上并不想要的行的数目。 · 布尔文本搜索包含匹配词 heavy，但 -rope 表示不包含以 rope 开头的词： `SELECT note_text FROM productnotes WHERE MATCH(note_text) AGAINST(‘heavy -rope‘ IN BOOLEAN MODE);` 匹配包含词 rabbit 和 bait 的行： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39;+rabbit +bait&#39; IN BOOLEAN MODE); 没有指定操作符，这个搜索匹配包含 rabbit 和 bait 中的至少一个词的行： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39;rabbit bait&#39; IN BOOLEAN MODE); 这个搜索匹配短语 rabbit bait 而不是匹配两个词 rabbit 和 bait： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; &quot;rabbit bait&quot; &#39; IN BOOLEAN MODE); 匹配 rabbit 和 carrot，增加前者的等级，降低后者的等级： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; &gt;rabbit &lt;carrot &#39; IN BOOLEAN MODE); 匹配词 safe 和 combINation，降低后者的等级： SELECT note_text FROM product notes WHERE MATCH(note_text) AGAINST(&#39; +safe +(&lt; combINation) &#39; IN BOOLEAN MODE); End of Part I]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>J2EE</tag>
        <tag>数据库</tag>
        <tag>MySQL</tag>
        <tag>JDBC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[廉价，素质，人权与公权力滥用]]></title>
    <url>%2F2017%2F12%2F05%2FCheap-quality-abuse-of-human-rights-and-public-power%2F</url>
    <content type="text"><![CDATA[中国人无疑是世界上最能隐忍的群体之一。 离开养尊处优的媒体圈子，你发现只能以穷游的方式去远方；辗转于地理学过却没走过的京九贵昆湘黔浙赣，吐槽联通出了城就傻逼的同时作为基本是孤品的一类旅客开始阅人无数。 高铁滚滚洪流之下，如今的绿皮火车自然以四海为家的农民工居多，但最明显的也只见于皖鲁之间；大多是一眼就能见生活所迫的碌碌迁徙者，间或有穿戴尚可的一级站之间的短途客，一身廉价西装工牌还没来得及摘的打工者，城镇企业家打扮腰揣几把车钥匙的生意人，与我也不清楚有没有钱的学生。虽然那扛不动蛇皮口袋的身躯着实可怜，而吐槽上了半车实实在在的民工可能偷着抽烟不容易管的列车员倒也滑稽。各地铁路局也风格迥异，以南昌职业素养最高，青岛次之，西安最糟，普天之下不得不感叹基建狂魔蛮荒的内心。 道听听到最多的莫过于我在xx呆过许多年这样的开头，虽然我经常背对他们，仍不难听出话语洋溢至脸上的走出来的自豪神情，即使如今仍不断被迫迁徙。而人群属性似乎注定了他们也有更多的弯路故事，比如我哥输掉了三轮车，我也输掉了，所以不得已出来打了几年工之类；大概都无暇顾及自己还是不是被总书记牵挂着。 更有，一家四口、期间尚有不足岁的婴儿，车厢空隙席地而睡，于是你都分不清建议其他出土文物般的人是不是该洗洗衣服再来坐车以示对别人的尊重这件事是不是政治正确。 也时常有游离于法外之地的“准传销者”，对落单的老人现场施法，以推销他们董事长十几岁自创中药企至今已治愈多少癌症的良方。 更多的，则是日常打工的家长里短，北方媳妇儿不爱洗衣服。除了男的钟爱乐福鞋，女的钟爱皮裤，不少人排斥读书教育与新事物，而对假药、封建迷信、TG都有着天真的执念。 公权力无孔不入的肆意侵入，高铁尚且每过一站布施几个红头文件，绿皮火车就干脆不考虑时宜的用抵挡不住的音量灌输所谓旅行文化，好似几年前去西安的夜车上被无数人建议过最好开小点暖气却始终一脸茫然的列车员。和谐社会，没有做“人”的机会。这是跟贫穷一样可悲的事情。 世界那么大。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>中国</tag>
        <tag>游记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 惰性初始化]]></title>
    <url>%2F2017%2F11%2F14%2FLazy-Instantiation-of-Java%2F</url>
    <content type="text"><![CDATA[为什么要使用惰性初始化：因为类中为基本类型时，能够自动被初始化为0，但是对象引用会被初始化为null。编译器不是简单的为每一个引用创建对象创建默认对象，这一点是很有用的，因为真要那样的话，会在很多情况下增加很多开销。那么如果想初始化这些引用，就可以在代码中的很多位置进行，其中“惰性初始化”是其中的一种方式。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Simple &#123; String s; public Simple(String si) &#123; s = si; &#125;//构造函数,内部为构造变量赋值 public String toString() &#123; return s; &#125; //复写 public void setString(String sstr) &#123; s = sstr; &#125;//普通函数&#125;class Second &#123; Simple simple; String s; public Second (String si) &#123; s = si; &#125;//构造函数,内部为变量赋值 public void check() &#123;//单纯检测simple是否已经创建. if(simple == null) System.out.println("simple is not initlized"); else System.out.println("simple is initlized"); &#125; private Simple lazy() &#123;//检测simple是否已经创建,如果没有创建就创建一个 if(simple == null) &#123; System.out.println("simple is creating"); simple = new Simple(s); &#125; return simple; &#125; public Simple getSimple() &#123;//获取simple的值 return lazy(); &#125; public void setSimple(String sNew) &#123;//设定simple的值 lazy().setString(sNew); &#125; public String toString() &#123; //复写tosring()方法,输出 return lazy().toString(); &#125;&#125;public class testLazy &#123; public static void main(String[] args) &#123; Second second = new Second("intit String"); second.check(); //输出:simple is not initlized //同时为second类中的变量s赋值为:s="intit String" System.out.println(second.getSimple()); //创建simple,为simple赋值:simple="intit String" //输出:simple is creating // intit String second.check(); //输出:simple is initlized second.setSimple("New String"); //输出:intit String System.out.println(second); //输出:New String &#125;&#125;]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J2SE</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java 的静态变量、静态方法、静态类]]></title>
    <url>%2F2017%2F11%2F09%2FStatic-in-Java%2F</url>
    <content type="text"><![CDATA[静态变量和静态方法都属于静态对象，它与非静态对象的差别需要做个说明。 Java静态对象和非静态对象有什么区别？比对如下： 非静态对象 静态对象 拥有属性 是类共同拥有的 是类各对象独立拥有的 内存分配 内存空间上是固定的 空间在各个附属类里面分配 分配顺序 先分配静态对象的空间 继而再对费静态对象分配空间，也就是初始化顺序是先静态再非静态 1、Java静态对象到底有什么好处A，静态对象的数据在全局是唯一的，一改都改。如果你想要处理的东西是整个程序中唯一的，弄成静态是个好方法。 非静态的东西你修改以后只是修改了他自己的数据，但是不会影响其他同类对象的数据。 B，引用方便。直接用 类名.静态方法名 或者 类名.静态变量名就可引用并且直接可以修改其属性值，不用get和set方法。 C，保持数据的唯一性。此数据全局都是唯一的，修改他的任何一处地方，在程序所有使用到的地方都将会体现到这些数据的修改。有效减少多余的浪费。 D，static final用来修饰成员变量和成员方法，可简单理解为“全局常量”。对于变量，表示一旦给值就不可修改；对于方法，表示不可覆盖。 2、静态变量、静态方法和静态块通常情况下，类成员必须通过它的类的对象访问，但是可以创建这样一个成员，它能够被它自己使用，而不必引用特定的实例。在成员的声明前面加上关键字static就能创建这样的成员。如果一个成员被声明为static，它就能够在它的类的任何对象创建之前被访问，而不必引用任何对象（跟类是否有static修饰无关）。 你可以将方法和变量都声明为static。static 成员的最常见的 例子是main( ) 。声明为static的方法有以下几条限制（main也是？？）： A，它们仅能调用其他的static 方法B，它们只能访问static数据C，它们不能以任何方式引用this 或super(this涉及到对象，super 与继承有关） 示例：Static 块仅在该类被加载时执行一次。下面的例子显示的类有一个static方法，一些static变量，以及一个static 初始化块。1234567891011121314151617public class TestNew &#123; static int a = 3; static int b; static void meth(int x)&#123; System.out.println("x = "+x); System.out.println("a = "+a); System.out.println("b = "+b); &#125; static &#123; System.out.println("static block initialized"); b = a*4; &#125; public static void main(String[] args) &#123; // TODO Auto-generated method stub meth(42); &#125; &#125; 执行结果是：static block initializedx = 42a = 3b = 12 上述class TestNew的执行顺序是：首先static 块执行(打印一条消息)，a被设置为3，最后b被初始化为a*4 成12。然后调用main()，main () 调用meth() ，把值42传递给x。3个println ( ) 语句引用两个static变量a和b，以及局部变量x 。 3、外部使用静态变量或者静态方法在定义它们的类的外面，static 方法和变量能独立于任何对象而被使用，你只要在类的名字后面加点号运算符即可。可以看到，这种格式与通过对象引用变量调用非static方法或者变量的格式类似。示例： 1234567891011121314class StaticDemo&#123; static int a = 42; static int b = 99; static void callme()&#123; System.out.println("a = "+a); &#125; &#125; public class TestNew &#123; public static void main(String[] args) &#123; // TODO Auto-generated method stub StaticDemo.callme(); System.out.println("b = "+StaticDemo.b); &#125; &#125; 执行结果：a = 42b = 99 4、静态内部类是指在一个类的内部，又定义了一个用static修饰的类。可以用C中的结构体内嵌结构体来理解。A，首先，用内部类是因为内部类与所在外部类有一定的关系，往往只有该外部类调用此内部类。所以没有必要专门用一个Java文件存放这个类。 B，静态方法、静态成员变量。它唯一的作用就是随着类的加载（而不是随着对象的产生）而产生，以致可以用类名+静态成员名直接获得。这样静态内部类就可以理解了，它可以直接被用 外部类名+内部类名 获得。举例如下： 123456789public class Build &#123; .............. public static class VERSION &#123; ................ public static final String RELEASE = getString("ro.build.version.release"); ................ &#125; ................&#125; 在外部可以直接通过Build.VERSION.RELEASE来访问。 参考原文：http://www.cnblogs.com/-0_0-/articles/1962368.html参考原文：http://blog.sina.com.cn/s/blog_5cd7f5b40100r0rt.html参考原文：http://zhidao.baidu.com/question/149873207.html参考原文：http://ddvcxj.blog.51cto.com/1064441/26534]]></content>
      <categories>
        <category>Coding</category>
      </categories>
      <tags>
        <tag>Java</tag>
        <tag>J2SE</tag>
        <tag>Coding</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观西]]></title>
    <url>%2F2017%2F10%2F21%2FEurope-Mid2017%2F</url>
    <content type="text"><![CDATA[Het Concertgebouw，当从来不知道中午十一点也能开音乐会的我坐在这家世界三大音响效果最佳的音乐厅之一的RCO主场，拍完照装完逼，准备听一段并不感冒的莫扎特K219，在几乎忽视了这松润甜的混响的确比干涩的国家大剧院高到不知哪里去的事实的同时，一阵雷动的掌声倏忽间将我埋进了齐齐站起的满场垂垂老矣的白发先生当中，生出一阵焦虑。 阿姆斯特丹德奥系目的地偏多的行程里阿姆斯特丹算是奇葩一朵，位列周游列国印象最佳，虽然整座城市大多只是以运河为经脉的老城环状地带以及清一色的联排建筑，大概也是因为荷兰人看上去比傲的要上天的德奥人nice以及从巴黎过去的一路看太多荷兰境内草场看到吐的缘故。搭积木般的小城里人行道有轨电车Tram甚至汽车混搭的交通，且不说两百多米一站的路程时常让你决断不了干脆走路还是花1个多欧去乘Tram，一些小街区出了车门两步路就能迈进一家店的体验可真是住在北京这种出了地铁车厢还要经过少说两段长梯到路面，再走十几分钟才能进家门的人不曾体会到的。 城小，于是文化生活的消息相对容易掌握，爱音乐之人前面的Het Concertgebouw自然不可错过，碰到RCO的演出最好。与之隔一片草地的梵高博物馆，也值得每个爱好者或者像我这般完全连不上平面艺术WiFi的人逛逛，展品不必多说，而从展馆设计到服务到展陈设计到路线几乎是垂直专业类博物馆里的翘楚，导览以及Audioguide也是至今逛到的博物馆里最好用的；可以说除了那本名画集的中文版封面标题排版之外，鲜有槽点。要是上溯到海上霸权的那些事儿，就得荷兰国家博物馆来撑场面了，只是贪多易乱，虽然乱不过卢浮宫，但也要抱着相当的耐心；除了著名打卡地《夜巡》，在日不落帝国都不曾见过如此密集的展现盛极一时的航海时代。 至于De Wallen那边tedious的橱窗长腿妹，放到东方男性oriented的市场里估计要垫底，就连后来的东欧也接受不能，而且被大麻味熏到头疼也并不是多好的体验，曼谷才是你们的福地。大概也因为太过出名，除了运河两边的橱窗，这里的小巷子里挤满了男女老少各色观光客，虽然真的不会有人冲亚洲长相的男性喊“发票”，但也能不时听到国内游客们“她们能有生意么？”的讨论。 维也纳作为德语区第二大城市的维也纳显然要比柏林幸运的多，昔日帝国与王朝的心血并未因战争受损太多，建筑一派雍容华贵，只是在巴黎已经对建筑审美疲劳的我美泉宫美景宫霍夫堡不是没去就是匆匆路过，唯一进过号称混杂各种建筑风格的St. Stephen’s教堂，修葺的影子挡不住本身的巍峨，这几天里唯有布拉格的圣维特可与之一拼。 而发现了艺术史博物馆这块福地绝对是在维也纳最大的惊喜，以“宝石雕刻”为主的装饰艺术不得不让你对这种原本印象中奇技淫巧的花哨玩意儿肃然起敬，简单到金银宝石雕刻的华贵器具，复杂到拟生物座钟及天文钟，远到埃及纸莎草死者之书，近到文具水晶这些科学启蒙时代的产物，远比伦敦的VA及大英的装饰艺术馆好看。 更不用说二层这种“课本名画”堆的到处都是，卡拉瓦乔、勃鲁盖尔、鲁本斯每个人都能挂一屋子的地方了。 艺术史博物馆与对面的自然史博物馆，是特雷西亚广场两侧几乎相同的两栋建筑，一个收藏了最多的宝石雕刻，一个收藏了最多的陨石和矿藏（大概也是最多的鹦鹉螺壳…）。一层鳞次栉比分布着各色矿藏，其中的衍生晶体除了让你感叹自然之无限诡谲之外别无他念，二楼的脊椎动物标本就比较无趣和常见；整体来说矿藏化石和陈年标本值得一逛，假如你对泡了两百多年的带状绦虫之类的奇葩展品感兴趣的话。首先不要被3000万件藏品的简介吓到，因为大概那几百只蚂蚁跟几百只瓢虫就能贡献好几个百分点…… 名声在外的金色大厅不常遇得上维也纳爱乐的演出，更多的是到处都有兜售的不知名乐团的旅游团曲目音乐会，还好我也不听施特劳斯……倒是临时起意跑去国家歌剧院碰碰站票的运气，第一次Opera的经历就这么3个欧贱卖了出去，歌剧院虽老却也为了照顾各国观众几乎每个座位都有不同语言的字幕提词器，然而还是在听完熟悉的第一幕配乐之后不可避免的逃了出去。德奥观众的严谨在于他绝对会群起而厉声制止那些意不在演出却有意无意制造噪音的人。 巴黎巴黎的沉淀是能直接把所有装逼的心态打回原形的地方，作为两个领域的纯小白，当你不知道该从历史开始看起还是城市建筑史开始看起的时候，就只是想哭。被奥斯曼新古典主义的中产阶级石砌建筑重重包围了两天的行程，也就依稀记得卢浮宫的乱，奥赛的莫奈，埃菲尔的小和圣母院全程懵逼的弥撒。 高潮出现在铁塔旁边的河畔博物馆Musée du Quai Branly，藏品多来自处在世界边缘的亚非拉和大洋洲；古希腊罗马雕塑再多，能见到的也大都是高度拟人化的风格，就算是怪力乱神也得尽量安个人的样子；土著先民可不管这一套，一路下来直感叹所谓“文明社会”想象力之匮乏。 萨尔茨堡多年以前受古典乐荼毒不深尚在新粉丝狂热时候留下了这样的豆瓣签名“老了能在萨尔茨堡的山下湖前有个小屋，每天走在街上就能听到巴赫”，能不能有个小屋两说，小城南边阿尔卑斯北麓以及去往维也纳的一路倒是林立各种精致的木屋建筑，但估计每天走在街上听到的只能是各种语言的旅游团喇叭声了。幸好不是在萨尔茨堡音乐节到此，或者在琉森音乐节去琉森，得见这种小城的本来面目只能以无聊概括，论景点恨不得全城一天可以逛两次，对于一个从城中心的酒店走着就能去中央车站的“城市”，生活一个月大概就能逛遍和吃遍所有的店了吧。 布拉格，没什么意思，Communism害死人。 FYI：“说走就走”其实对于欧洲是个不小的挑战，时常会让你面临房少车少而人多的状况，比如提前几个月能比提前几天便宜两三倍的火车票，幸好我这种辞职流浪时间重要不过钱包的时候也有便宜到不行的跨国巴士可以选择，无论是巴黎往阿姆斯特丹的Euroline、德国主营周边的Flixbus、捷克主营的Regiojet都是除了时间之外完全不输火车的体验；不过巴士跑高速，火车钻山，后者风景常会好过前者；然而并非高铁的大多数线路真的很难让你找到时间上的优势。至于房，除非太穷或者酒店一间不剩，还是不要住民宿这种东西了。 妨碍一时冲动的还有比语言更难懂的各国市内交通，已经无力吐槽，对于布拉格这种最糟糕的城市还是早日买24小时票保命，免得满地找售票机甚至假如身上还没有合适的硬币克朗；反正除了逃票之外完全找不到日本那种往售票机里无脑扔一把硬币一秒钟收到找零的快感。 莱比锡差点忘了巴赫爸爸。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>欧洲</tag>
        <tag>博物馆</tag>
        <tag>KHM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[观东]]></title>
    <url>%2F2017%2F10%2F08%2FJapan-Early2017%2F</url>
    <content type="text"><![CDATA[人大概在这两种时候会心生忐忑，见自己初喜欢的人，和见自己喜欢过的未知，后者如日本。 该怎么形容“我与日本”这样的话题呢？始终到临走前，我还是没想好的哇。而且总是会想起跟过去有关的事。你的童年与她有关，你的梦想与她有关，你对世界的幻想与她有关，你对爱情的期望与她有关，你的成人礼都与她有关，这么多角色扭打在一起的时候，忐忑就更悠远绵长起来。 大阪价值观如我这般摇摆的人就不应该在去关西前先入为主的听了《日谈公园》，主播菌口中的大农村的印象就那么结实的印到了大阪的首日里；且不说爱彼迎的小屋再一次让人咬牙切齿的痛恨了一回摄影师这个职业（不过也倒是目前见过设施最全的民宿了喂），心斋桥这种小商品一条街也实在让人提不起兴趣，任你优衣库的整栋楼再多可以逛，药妆店吆喝中文的姑娘们再好看，也只是喜欢躲到河边排个一兰拉面尝试一下各种软硬面条和汤底的搭配。 对于一个ぜんぜん弄不懂织田信长丰臣秀吉德川家康谁创业谁守业的人来说，天守城这种大阪为数不多的景点也是百无聊赖，好在旁边就是大阪历史博物馆，在经历了跟基本听不懂英语的接待比划半天我到底该不该存包然后干脆趁那个难缠的人不在溜了进去之后，不得不说总算是找到了抵日两天的精神寄托；硬货不多，要不也不会满是中国都唐了日本同期还是以为属于绳纹弥生时代的陶罐之类的东西；不过日本人的精致还是在还原江户生活的模型里体现的淋漓尽致，比南博负一层的民国时代大模型们难做多了…… 打定主意不怎么做攻略的我提前一个周才知道买了买电话卡跟地铁票，遗憾是错过了东京的三鹰吉卜力这个需要提前一月订票的情怀之地，但惊喜也是有的，梅田就是第一个。说来也巧，在那个有百八十个出口的站把我绕晕之前，捡了个百货商场出口的门就夺门而逃了，路遇现在才知道曲风叫做neo soul的band，看在keyboard姑娘美，哦不，是好听而且还是少见的不是solo的份上，现场不失所望的越来越燃，至少听起来比买回来的拘谨的录音室CD张狂的多，所以谁会说未来Live不是比Record更好更有发展的音乐形式呢？嗯已经在打FUJI ROCK的主意了。 京都真正爱上日本也是从京都开始的吧。当然还是不太推荐在游客高峰期去岚山这种地方，必然是满脑子WTF的怀疑这是个假日本……攻略都是骗人的……要不是有抹茶冰淇淋的拯救，大概对京都的印象也不会好。 踩了踩岚山的竹林，并且没看懂周总理写的是什么诗，小火车回到住地四条大宫的时间还早，折转就去了八坂神社圆山公园二年坂，然后就在四条出口和公园见识了日本人都是怎么卖艺的……大叔拿把破琴指弹玩儿的再认真点就赶上押尾了，而另一位大叔的乐器是两万多的手碟，真是不知道给多少钱合适啊。 第二日的雨让原本金阁寺银阁寺各种寺伏见稻荷打卡一日游的计划被打乱，跑去京都博物馆的室内临时躲雨行程也因为傲娇的非闭馆日闭馆而只花门票的价格参观了一个庭院终结。在纠结总不至于为了一点小雨就牺牲一天住宿费的时候，还是强忍着坐电车去扫一个景点算一个，那就伏见稻荷吧。 虽然没见过阳光嶙峋的千鸟居，但雨中同样流连。伏见稻荷的鸟居漫山遍野，如果你挤不过山脚下围住它们拍照的游客们，山上一点儿不输于此，无论体量还是规模；当然半腰下山的一段奉满了各路神像，要是再有点儿阴天，大概走着就会怕会不会像千寻的爸妈一样被抓去变成猪。 除了文保原因的电车不多，店家关门过早也是不小的困扰，想来八坂神社以上的二年坂三年坂入夜挑灯应该是蛮迷离隔世的一番景色，奈何天一擦黑就纷纷收摊，简直是让人羡慕嫉妒恨的日落而息的生活状态。 总之这是个遗憾大过惊喜的地方，换句话说还对它有绵延不止的期待，比如没去成金阁寺和没吃成怀石料理，anyway，当在御陵卫外边追着那一线阳光拍影子的时候，大概就决定了以后会去常住的吧。 东京去过伦敦之后，我一直以为，东京大概也是类似的“大城市”，那句“如果你厌倦了伦敦，你就厌倦了生活”大概也能套用到后者身上。谁能不爱东京呢？ 不知是否被贵到吃土的新干线伤了神，反正东京的电车还是再次印证了在日本的几天依然没弄懂铁路系统的问题；在出东京站出了半小时、转大手町找了半小时之后，总算找到了去押上的线。好在如此的折腾又换到了一个惊喜，酒店旁边就藏着东京的两家Pokemon Center之一，不由分说抱一只皮卡丘回去是当然的，只是不得不吐槽，除了皮卡丘的等身之外，其他周边还是粗糙，而且一架子不认识的精灵都在冲你说：你老了。 东京的游记至今已经理不出头绪，就像在东京的几天永远没有头绪一样，坐地铁走到哪儿，哪儿都可以玩上半天，计划的落空与补给来的惊喜错综交织，到最后你就早已不记得为玩而玩这件事了。本来的赏樱路线变成了银座那连比弗利和广东道都比不了的大牌林立，本来打个卡就走的早稻田却意外碰上了无法理解的春季毕业季，唯有秋叶原去的符合行程，而那堆成山的手办和小电影真是让人有心无力。 转头说说文化的事，住在押上的另一个好处是，上野就在附近，当然樱花尚不吐蕊的上野恩赐公园并不好玩，而整个上野像柏林的博物馆岛和伦敦特拉法加广场周围一样遍布博物馆，从森美术馆开始，到柯布西耶设计的国立西洋美术馆，到始终没机会进去的自然博物馆，到逛了一天半收藏了规模宏大的植轮跟太刀的最大的东京国立博物馆。 当然六本木偶遇的印度Harsha的Charming Journey展，也比东京塔的夜景有趣，毕竟世界上只有爱情和艺术这两件东西使我们的生活值得苟且。 这样的苗头像极了伦敦四万步的经历，既然肯定有下次，最后一天的行程干脆完全留给了花钱不多的博物馆系列（日本每个博物馆都花钱这很蛋疼），看在上野的那一片离酒店近取行李也方便而且晚上还开的份上就先去了《博物志》里推荐的印刷博物馆。虽然没怎么去过国内的主题博物馆，没得比较，但还是惊叹于展陈的完整性和事无巨细，展品收集上是否丰富有代表性不好评论，毕竟不懂，然而就教学作用来说，完全是白痴看完也能懂的节奏。 出门有每天一节接待六位的印刷体验课，看在人不多的份上尽管不怎么懂日语我还是抱着看展的余热排在门口，奈何半天才找出一位会英语的能交流的叫やまだ的小姑娘，全程被特殊对待并且拿据说是40年代的英产手动活字印刷机印了七张写我名字的信笺而告终。 其他，且不说服务与清洁程度，就是自动化程度之高，也是去过的其他发达国家都无法企及的，路边随处可见的自动贩卖机几乎永远有冷饮热咖啡（似乎厂牌还分的很明显，三得利的机器永远只有旗下的各式咖啡，朝日的机器啤酒居多，伊右卫门的机器自然是热茶居多，其他不知名的则提供各种品牌的小甜水），一兰（要是不等位的话）和松屋这样的快餐以及京都车站的拉面一条街几乎靠自动点餐机就能解决问题，永远提供中日韩英四国语言，酒店的自动洗衣烘干状态能显示到客房电视上，社区也总有自动洗衣门店，就连东京国立博物馆的门票都是自动投币买，车站的精算机也是个神奇的东西。 能在这样一个不需要见人说人话见鬼说鬼话的地方，不愁吃不愁喝，有温暖的周末，做个平凡人没什么不好。]]></content>
      <categories>
        <category>游记</category>
      </categories>
      <tags>
        <tag>游记</tag>
        <tag>大阪</tag>
        <tag>东京</tag>
        <tag>京都</tag>
      </tags>
  </entry>
</search>
